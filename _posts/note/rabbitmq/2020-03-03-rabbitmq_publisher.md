---
bg: 'rabbitmq.jpeg'
layout: post
title:  "RabbitMQ发布者性能权衡"
crawlertitle: "rabbitmq"
summary: ""
date:   2020-03-03 18:26:00 +0700
categories: posts
tags: 'rabbitmq'
author: 宋天
---

RabbitMQ消息发布的性能权衡




Rabbitmq提供了很多选项功能来保证消息的可靠性，但这需要我们在性能和可靠性之间进行权衡，AMQP规范提供消息中的事务，消息持久化，可靠消息等，RabbitMQ提供消息确认，HA队列等来保证消息的可靠性


## 平衡速度和可靠性

遵循金发姑娘原则==刚刚好，每个为了可靠性的机制都对性能产生一定的影响，当单个使用时，可能吞吐量不会有显著的差异，当组合使用时，将会产生重大影响，只有通过性能基准测试，才能找到性能和可靠投递的平衡

下面是几个找到刚刚好解决方案的问题

- 消息发布时保证消息进入队列的重要性有多高
- 如果消息无法路由，是否应将消息返回给发布者
- 如果消息无法路由，是否应该将其发生到其他地方稍后进行重新路由
- 如果RabbitMQ服务器崩溃，可以接受信息丢失吗
- rabbitmq在处理新消息时，是否应该确认它已经为发布者执行了所有请求的路由和持久化任务？
- 消息发布者是否可以批量投递消息，然后从rabbitmq收到一个确认用于表明所有请求的路由和持久化任务已经批量应用到所有的消息中？
- 如果你要批量发布消息，而这些消息需要确认路由和持久化，那么对每一条消息是否需要对目标队列实现真正意义上的原子提交？
- 在可靠投递方面是否有可接受的平衡性，你的发布者可以使用它来实现更高的性能和消息吞吐量吗？
- 消息发布还有哪些方面会影响消息吞吐量和性能？

### 如果没有保证机制

- 我们只能用消息队列发布一些不是很重要的消息，即使消息丢失或者RabbitMQ重启也影响不大

### mandatory

此标志告诉RabbitMQ是强制的(mandatory), 如果消息不可路由，它应该通过Basic.Return命令将消息返回给发布者，如果消息路由成功，发布者不会收到通知。

- python的rabbitpy库自动接收Basic.Return,并在信道范围内收到该调用时触发MessageReturnedException异常
- 其他库需要注册一个回调方法来监听并响应这个RPC调用，这个过程就好像在消费消息一样接收到刚才发布的无法路由的消息

### 发布者确认

此功能是RabbitMQ的功能，只支持特定库, 开启之后，RabbitMQ接收到发布者的消息之后会返回给发布者Basic.Ack或者Basic.Nack来告知发布者消息被成消费者消费，持久化或者无法路由。

![时序图](https://cdn.jsdelivr.net/gh/songjiyang/myPic@main/blog/04fig04_alt.jpg)

- 可以使用回调来处理Basic.Ack或者Basic.Nack, 或者同步等待
- 发布者确认不会和事务一起工作，是一个AMQP TX的轻量级并提供高性能的代替方案

### 备用交换机

当指定的交换机无法路由消息时，将消息路由给备用交换机

- 当mandatory为true时，将备用交换机发送消息满足了消息以及被发布这一条件，所以不会再向发布者发送Basic.Return
- 声明exchange的时候使用alternate-exchange属性来声明备用交换机


### 事务和批量操作

在投递确认出现之前，确保消息被成功投递的唯一方法是事务，AMQP事务可以将消息批量发送的RabbitMQ, 然后提交或回滚
![时序图](https://cdn.jsdelivr.net/gh/songjiyang/myPic@main/blog/04fig06_alt.jpg)

- RabbitMQ事务中的每个命令作用同一个队列时才能保持真正的原子性
- 将delivery-mode设置为2在事务中需要等待更长的时间
- 可以使用投递确认用作事务的轻量级代替方案


### HA队列

HA队列时RabbitMQ对AMQP的增加功能，HA队列需要RabbitMQ集群，发布消息到高可用队列时，消息会被发送到集群中的所有服务器或者部分服务器

- 使用x-ha-policy，和x-ha-nodes属性声明高可用队列
- RabbitMQ集群分为主节点和辅助节点，主节点宕机会重新选择辅助节点当主节点
- 当在HA队列使用事务或者投递确认，要确保所有服务器都成功才会响应，所以延迟会更大

### delivery-mode

当设置为2时，告诉RabbitMQ将消息写入磁盘，这被称为消息持久化，可以确保RabbitMQ服务因任何原因重启之后，消息还在队列中

- 需要服务器提供良好的写入能力，当服务器IO能力不足时，会让消息写入磁盘等待，导致消息吞吐量降低
- 是保证消息最终被投递的重要方式之一，但实现它的代价也是最大的


### RabbitMQ回推

RabbitMQ使用Channel.Flow询问发布者让发布者停止发送，但这不是一种有效的方式，使用TCP背压停止接收TCP套字节上的底层数据

- RabbitMQ内部使用信用来管理回推发布者的时机
- RabbitMQ3.2扩展了AMQP规范，增加了Connection.Blocked和Connection.Unblocked让客户端来询问服务器是否阻塞


## 小结

RabbitMQ提供了很多方式来保证消息最终投递，但我们需要根据实际需求来从性能和保证之间做权衡